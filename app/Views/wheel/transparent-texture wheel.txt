
        // Draw the wheel with proportional segments
        function drawWheel() {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 10; // Adjust radius for spacing
    const outerRadius = radius - 55; // Outer radius for image placement
    const equalAngle = 2 * Math.PI / segments.length; // Each segment gets an equal angle

    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas before redrawing

    let currentAngle = rotationAngle; // Start at the current rotation angle

    // Add shadow to the border
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;

    // Draw the white border around the wheel
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius + 1, 0, 2 * Math.PI); // Outer circle (border)
    ctx.lineWidth = 10; // Border width
    ctx.strokeStyle = '#fff'; // Border color
    ctx.stroke();
    ctx.lineWidth = 1; // Reset line width

    // Remove shadow for inner drawings
    ctx.shadowColor = 'transparent';

    segments.forEach((segment, index) => {
        // Define the segment color dynamically
        let color;
        if (index === 0 && segments.length % 3 != 0) {
            color = '#0daff0'; // First segment special color
        } else {
            // Alternating colors for the rest
            switch (index % 3) {
                case 0:
                    color = '#fd2654'; // Red
                    break;
                case 1:
                    color = '#fdce26'; // Yellow
                    break;
                case 2:
                    color = '#0daff0'; // Blue
                    break;
            }
        }

        // Draw the segment
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + equalAngle);
        ctx.closePath();

        if (segment.jackpot === "Yes" && jackpotTexture) {
    // Draw the background color first
    ctx.fillStyle = color; // Set the base color
    ctx.fill();
    
    // Overlay the pattern with transparency
    ctx.globalAlpha = 0.2; // Adjust transparency for the pattern (0.0 to 1.0)
    let pattern = ctx.createPattern(jackpotTexture, 'no-repeat'); // Create the pattern
    ctx.fillStyle = pattern; // Set the pattern as the fill style
    ctx.fill(); // Apply the pattern
    ctx.globalAlpha = 1.0; // Reset transparency
} else {
    // For non-jackpot segments, use only the base color
    ctx.fillStyle = color;
    ctx.fill();
}



        ctx.fill();

        // Draw the image for the segment (if available)
        if (segment.imgElement) {
            const imgSize = 90; // Image size
            const imgX = centerX + Math.cos(currentAngle + equalAngle / 2) * outerRadius - imgSize / 2;
            const imgY = centerY + Math.sin(currentAngle + equalAngle / 2) * outerRadius - imgSize / 2;

            ctx.save();
            ctx.beginPath();
            ctx.arc(imgX + imgSize / 2, imgY + imgSize / 2, imgSize / 2, 0, 2 * Math.PI);
            ctx.clip(); // Clip the image to fit the segment
            ctx.drawImage(segment.imgElement, imgX, imgY, imgSize, imgSize);
            ctx.restore();
        }

        currentAngle += equalAngle; // Move to the next segment
    });

    // Draw the center image (without shadow)
    drawCenterImage(); // Your function to draw the center image

    // Draw the pointer on top
    drawPointer();
}

